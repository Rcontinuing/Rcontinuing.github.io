<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于本网站</title>
    <url>/123/</url>
    <content><![CDATA[<h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p>​		爱看不看</p>
<span id="more"></span>

<p><strong>目的</strong>：突发奇想搭建一个博客网站，用来记录自己的学习和生活。</p>
<p><strong>内容</strong>：我会将目前所学的一些内容上传该网站。</p>
<p><strong>你</strong>：目前网站左侧有音乐按钮，这几个都是我的网易云歌单，如果你想听你的歌单，按照以下步骤操作。</p>
<p>找到自己音乐平台的歌单 id（只支持网易云）。如下图</p>
<img data-src="id.png" style="zoom: 67%;">



<p>在地址栏可以看到自己的<strong>歌单 id</strong>, 图中是 8729907126，你可以把你的 id 发在评论区，不出意外第二天你就可以看到你的歌单。（已经再努力支持其他音乐平台了）。</p>
<p><strong>最后</strong>：欢迎大家提任何意见，包括网站，学习，以及其他建议，一起学习。</p>
<p>​		</p>
]]></content>
      <categories>
        <category>6</category>
      </categories>
      <tags>
        <tag>6</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1. 介绍</h3><p><strong>什么是位运算呢？位运算就是二进制数据进行运算的运算符，这里我们主要说到左移，右移，按位与，按位或，按位取反，异或。</strong></p>
<h3 id="2-位运算的使用"><a href="#2-位运算的使用" class="headerlink" title="2.位运算的使用"></a>2. 位运算的使用</h3><span id="more"></span>

<h4 id="（1）左移"><a href="#（1）左移" class="headerlink" title="（1）左移<<"></a>（1）左移 &lt;&lt;</h4><blockquote>
<p><strong>左移 &lt;&lt; 顾名思义就是向左移动。</strong><br>如数据：1010&lt;&lt;1 1010 左移一位后：10100 即向左移动，低位补 0</p>
</blockquote>
<h4 id="（2）右移"><a href="#（2）右移" class="headerlink" title="（2）右移>>"></a>（2）右移 &gt;&gt;</h4><blockquote>
<p><strong>右移 &gt;&gt; 顾名思义就是向右移动</strong><br>如数据：1010&gt;&gt;1 1010 右移一位：101 向右移动</p>
</blockquote>
<h4 id="（3）按位与"><a href="#（3）按位与" class="headerlink" title="（3）按位与&amp;"></a>（3）按位与 &amp;</h4><blockquote>
<p><strong>按位与与代码中的逻辑运算从差不多，两个都是 1 才是 1，否则是 0.</strong><br>如：1 0 1 0 &amp; 1 1 0 0 ———————————— 1 0 0 0</p>
</blockquote>
<h4 id="（4）按位或"><a href="#（4）按位或" class="headerlink" title="（4）按位或|"></a>（4）按位或 |</h4><blockquote>
<p><strong>按位或和我们代码中加的逻辑运算差不多，在对两个二进制数进行或运算时，只要其中一个有 1，那么就是 1，两个都为 0 才是 0.</strong><br>如：1 0 1 0 | 0 1 1 0 _____________ 1 1 1 0</p>
</blockquote>
<h4 id="（5）按位取反"><a href="#（5）按位取反" class="headerlink" title="（5）按位取反~"></a>（5）按位取反～</h4><blockquote>
<p><strong>按位取反就是对于每一位 1 变成 0,0 变成 1.</strong><br>如：~1010 取反后：0101</p>
</blockquote>
<h4 id="（6）异或"><a href="#（6）异或" class="headerlink" title="（6）异或^"></a>（6）异或 ^</h4><blockquote>
<p><strong>异或就是一位一位查看，看看是不是不一样，不一样就是 1，反之就是 0</strong><br>如： 1 0 1 0 0 1 ^ 1 1 0 0 1 0 _______________ 0 1 1 0 1 1</p>
</blockquote>
<h3 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3. 结论</h3><p><strong>1：任何数异或 0 是不变的，1^0=1,0^0=0</strong><br><strong>2: 任何数异或 1 取反，1^1=0,0^1=1</strong></p>
<p><strong>3: 任何数和其自身做异或运算，结果是 0</strong></p>
<p><strong>4. 异或运算满足交换律和结合律</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分页实现</title>
    <url>/%E5%88%86%E9%A1%B5%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><span id="more"></span>

<h2 id="1-pagehelper"><a href="#1-pagehelper" class="headerlink" title="1.pagehelper"></a>1.pagehelper</h2><h3 id="1-1使用："><a href="#1-1使用：" class="headerlink" title="1.1使用："></a>1.1 使用：</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1.导入依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">5.2</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//2.在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</span></span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">	&lt;!--设置分页插件--&gt;</span><br><span class="line">	&lt;plugin interceptor=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//3.开启分页功能</span></span><br><span class="line">PageHelper.startPage(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-2测试用例"><a href="#1-2测试用例" class="headerlink" title="1.2测试用例"></a>1.2 测试用例</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testPageHelper</span><span class="params">()</span>{</span><br><span class="line">       ApplicationContext app=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"applicationContext-mybatis.xml"</span>);</span><br><span class="line">       <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> (SqlSessionFactory)app.getBean(<span class="string">"sqlSessionFactory"</span>);</span><br><span class="line">       <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">       <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//在查询语句之前，开启分⻚功能。</span></span><br><span class="line">       PageHelper.startPage(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">       List&lt;User&gt; users = userMapper.selectAllUser();</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//封装PageInfo对象</span></span><br><span class="line">       PageInfo&lt;User&gt; pageInfo=<span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;User&gt;(users);</span><br><span class="line">       </span><br><span class="line">       System.out.println(<span class="string">"总记录数："</span>+pageInfo.getTotal());</span><br><span class="line">       System.out.println(<span class="string">"总页数："</span>+pageInfo.getPages());</span><br><span class="line">       System.out.println(<span class="string">"一页的大小："</span>+pageInfo.getSize());</span><br><span class="line">       System.out.println(<span class="string">"结果集："</span>+pageInfo.getList());</span><br><span class="line">       System.out.println(<span class="string">"前一页："</span>+pageInfo.getPrePage());</span><br><span class="line">       System.out.println(<span class="string">"后一页："</span>+pageInfo.getNextPage());</span><br><span class="line">       System.out.println(pageInfo.isHasPreviousPage());</span><br><span class="line">       System.out.println(pageInfo.isHasNextPage());</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">总记录数：<span class="number">8</span></span><br><span class="line">总页数：<span class="number">3</span></span><br><span class="line">一页的大小：<span class="number">3</span></span><br><span class="line">结果集：Page{count=<span class="literal">true</span>, pageNum=<span class="number">2</span>, pageSize=<span class="number">3</span>, startRow=<span class="number">3</span>, endRow=<span class="number">6</span>, total=<span class="number">8</span>, pages=<span class="number">3</span>, reasonable=<span class="literal">false</span>, pageSizeZero=<span class="literal">false</span>}</span><br><span class="line">[com.pojo.User@41e68d87, com.pojo.User@49ff7d8c, com.pojo.User@29526c05]</span><br><span class="line">前一页：<span class="number">1</span></span><br><span class="line">后一页：<span class="number">3</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-3常见属性"><a href="#1-3常见属性" class="headerlink" title="1.3常见属性"></a>1.3 常见属性</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//		  private int pageNum; //当前页</span></span><br><span class="line"><span class="comment">//        private int pageSize; //每页的数量</span></span><br><span class="line"><span class="comment">//        private int size; //当前页的数量</span></span><br><span class="line"><span class="comment">//由于startRow和endRow不常用，这里说个具体的用法</span></span><br><span class="line"><span class="comment">//可以在页面中"显示startRow到endRow 共size条数据"</span></span><br><span class="line"><span class="comment">//当前页面第一个元素在数据库中的行号</span></span><br><span class="line"><span class="comment">//        private int startRow;</span></span><br><span class="line"><span class="comment">//        private int endRow; //当前页面最后一个元素在数据库中的行号</span></span><br><span class="line"><span class="comment">//        private long total; //总记录数</span></span><br><span class="line"><span class="comment">//        private int pages; //总页数</span></span><br><span class="line"><span class="comment">//        private List&lt;T&gt; list; //结果集(每页显示的数据)</span></span><br><span class="line"><span class="comment">//        private int firstPage; //第一页</span></span><br><span class="line"><span class="comment">//        private int prePage; //前一页</span></span><br><span class="line"><span class="comment">//        private boolean isFirstPage = false;  //是否为第一页</span></span><br><span class="line"><span class="comment">//        private boolean isLastPage = false; //是否为最后一页</span></span><br><span class="line"><span class="comment">//        private boolean hasPreviousPage = false; //是否有前一页</span></span><br><span class="line"><span class="comment">//        private boolean hasNextPage = false; //是否有下一页</span></span><br><span class="line"><span class="comment">//        private int navigatePages; //导航页码数</span></span><br><span class="line"><span class="comment">//        private int[] navigatepageNums; //所有导航页号</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-4注意事项"><a href="#1-4注意事项" class="headerlink" title="1.4注意事项"></a>1.4 注意事项</h3><figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">使用pagehelper时会出现失效的情况</span><br><span class="line">PageHelper.startPage(int pageNum, int pageSize)只对该语句以后的第一个查询语句得到的数据进行分页</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-5实现原理"><a href="#1-5实现原理" class="headerlink" title="1.5实现原理"></a>1.5 实现原理</h3><p>主要是通过拦截器（Interceptor）来实现。在 MyBatis 中，提供了 Interceptor 接口用于对 SQL 语句进行拦截和处理，PageHelper 就是实现了这个接口，从而实现了对 SQL 语句的拦截和分页处理。</p>
<p>PageHelper 在拦截器中主要做了如下几个事情：</p>
<ul>
<li>解析分页参数：通过拦截 Executor 的 query () 方法，获取传入的参数，解析出当前所在的页码、每页显示的数据量等分页参数。</li>
<li>生成分页 SQL：通过拦截 StatementHandler 的 prepare () 方法，将原始的 SQL 语句修改为分页查询的 SQL 语句，具体实现方式是根据当前数据库类型，使用相应的方言（Dialect）生成分页查询语句。</li>
<li>执行分页查询：通过拦截 Executor 的 query () 方法，将修改后的 SQL 语句执行，并将结果保存在 Page 对象中，同时返回分页查询结果 List。</li>
<li>生成分页信息：通过自定义 Page 对象，保存当前页码、每页显示的数据量、总记录数以及分页查询结果 List，最终返回 PageInfo 对象，包含了分页查询的所有信息。</li>
</ul>
<p>具体分析：</p>
<p>List<user> users = userMapper.selectAllUser();</user></p>
<p>其中 User 是 page 对象，而 Page 对象继承自 JDK 中的 ArrayList，扩展并封装了一些 page 相关的字段，如页码，每页大小，总记录数，总页数等。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Closeable</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页码，从1开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNum;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startRow;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 末行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> endRow;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总页数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pages;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含count查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">count</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页合理化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean reasonable;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当设置为true的时候，如果pagesize设置为0（或RowBounds的limit=0），就不执行分页，返回全部结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean pageSizeZero;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行count查询的列名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String countColumn;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String orderBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只增加排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> orderByOnly;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sql拦截处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BoundSqlInterceptor boundSqlInterceptor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> BoundSqlInterceptor.Chain chain;</span><br></pre></td></tr></tbody></table></figure>



<p>PageHelper.startPage(pageNum, pageSize)</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开始分页</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageNum      页码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize     每页显示数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count        是否进行count查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reasonable   分页合理化,null时用默认配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSizeZero true且pageSize=0时返回全部结果，false时分页,null时用默认配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Page&lt;E&gt; <span class="title function_">startPage</span><span class="params">(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize, <span class="type">boolean</span> count, Boolean reasonable, Boolean pageSizeZero)</span> {</span><br><span class="line">    Page&lt;E&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;E&gt;(pageNum, pageSize, count);</span><br><span class="line">    page.setReasonable(reasonable);</span><br><span class="line">    page.setPageSizeZero(pageSizeZero);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当已经执行过orderBy的时候</span></span><br><span class="line">    Page&lt;E&gt; oldPage = getLocalPage();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldPage != <span class="literal">null</span> &amp;&amp; oldPage.isOrderByOnly()) {</span><br><span class="line">        page.setOrderBy(oldPage.getOrderBy());</span><br><span class="line">    }</span><br><span class="line">    setLocalPage(page);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到该方法将分页信息作为构造器参数实例化 Page 对象，调用 <code>getLocalPage()</code> 获取一个旧的 Page 对象，最后调用 <code>setLocalPage(page);</code> 把新创建的 Page 对象 set 进去。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Page&gt; LOCAL_PAGE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Page&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">getLocalPage</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> LOCAL_PAGE.get();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setLocalPage</span><span class="params">(Page page)</span> {</span><br><span class="line">        LOCAL_PAGE.set(page);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>从 ThreadLocal 中获取 Page 对象，将 Page 对象 set 到 ThreadLocal 中。</p>
<p>以上是 PageHelper 实现分页的原理，总结一下：</p>
<p>Mybatis 在四个地方留了扩展点，可以通过自定义拦截器实现 Interceptor 接口的 plugin 方法，执行自定义逻辑，可以通过该方法对 Executor、ParameterHandler、ResultSetHandler、StatementHandler 四个对象进行增强、扩展。</p>
<p>PageHelper 实现了 Interceptor 接口，它的 plugin 方法调用 Plugin.wrap 方法对目标对象进行包装，包装成一个代理对象并返回，代理类的实现就是 Plugin 自身。</p>
<p>Plugin.wrap 方法判断目标对象是否需要返回代理对象，判断依据是：Interceptor 实现类（这里是 PageHelper) 上注解标注的类是否包含目标对象所属类。这里 PageHelper 上注解标注参数为 Executor 对象，所以创建 Executor 对象会返回代理对象。</p>
<p>当调用 Executor 对象的方法时会进入到 Plugin.invoke 方法。invoke 方法会判断是否需要走拦截器的 intercept 方法，判断方式是取拦截器上的注解标注的方法，这里 PageHelper 标注的为 executor.query (四个参数的那个)，所以调这个时才会被拦截器拦截，其余方法还用原始对象调用。</p>
<p>PageHelper 的 intercept 方法调用 SqlUtil 的 intercept 方法最终调 SqlUtil.doIntercept 方法。在这个方法里会执行 count 语句，并将结果放到 page 对象里，然后判断需要分页，则将分页 sql 拼在原始 sql 上，然后执行。</p>
<p>PageHelper 实现了 Interceptor 拦截器接口，并拦截 Executor 的 query 方法，在执行前 PageHelper 会在原始 SQL 前拼装分页相关的 SQL。</p>
]]></content>
      <tags>
        <tag>pagehelper</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解 ThreadLocal</title>
    <url>/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3ThreadLocal/</url>
    <content><![CDATA[<h2 id="深入了解ThreadLocal"><a href="#深入了解ThreadLocal" class="headerlink" title="深入了解ThreadLocal"></a>深入了解 ThreadLocal</h2><span id="more"></span>

<h3 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal 简介</h3><p>ThreadLocal 叫做线程变量，意思是 ThreadLocal 中填充的变量属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal 为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<blockquote>
<p>即 ThreadLocal 类用来提供线程内部的局部变量，不同的线程之间不会相互干扰。</p>
</blockquote>
<p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。</p>
<p>这里有几点需要注意：</p>
<ul>
<li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。</li>
<li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题。</li>
<li>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。</li>
<li>ThreadLocal 变量通常被 private static 修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</li>
</ul>
<p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景</p>
<h3 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> num01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal=<span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span>{</span><br><span class="line">        <span class="comment">//打印当前线程中本地内存中本地变量的值</span></span><br><span class="line">        System.out.println(s + <span class="string">" :"</span> + threadLocal.get());</span><br><span class="line">        <span class="comment">//清除本地内存中的本地变量</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                ThreadLocalDemo.threadLocal.set(<span class="string">"local_A"</span>);</span><br><span class="line">                print(<span class="string">"A"</span>);</span><br><span class="line">                System.out.println(<span class="string">"remove后："</span>+threadLocal.get());</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                ThreadLocalDemo.threadLocal.set(<span class="string">"local_b"</span>);</span><br><span class="line">                print(<span class="string">"B"</span>);</span><br><span class="line">                System.out.println(<span class="string">"remove后："</span>+threadLocal.get());</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">A :local_A</span></span><br><span class="line"><span class="comment">remove后：null</span></span><br><span class="line"><span class="comment">B :local_b</span></span><br><span class="line"><span class="comment">remove后：null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>示例表明两个线程分表获取了自己线程存放的变量，他们之间变量的获取并不会错乱</p>
</blockquote>
<h3 id="三、原理剖析"><a href="#三、原理剖析" class="headerlink" title="三、原理剖析"></a>三、原理剖析</h3><h4 id="1-set-方法："><a href="#1-set-方法：" class="headerlink" title="1.set()方法："></a><strong>1.set () 方法：</strong></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> {</span><br><span class="line">        <span class="comment">//1、获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，</span></span><br><span class="line">        <span class="comment">//则直接更新要保存的变量值，否则创建threadLocalMap，并赋值</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 初始化thradLocalMap 并赋值</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> {</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> {</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>ThreadLocal set 赋值的时候首先会获取当前线程 thread, 并获取 thread 线程中的 ThreadLocalMap 属性。如果 map 属性不为空，则直接更新 value 值，如果 map 为空，则实例化 threadLocalMap, 并将 value 值初始化。</p>
<h4 id="2-ThreadLocalMap"><a href="#2-ThreadLocalMap" class="headerlink" title="2.ThreadLocalMap"></a><strong>2.ThreadLocalMap</strong></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> {</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">       * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">       * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">       * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">       * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">       * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">          <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">          Object value;</span><br><span class="line"> </span><br><span class="line">          Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">              <span class="built_in">super</span>(k);</span><br><span class="line">              value = v;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line"> </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p> 可看出 ThreadLocalMap 是 ThreadLocal 的内部静态类，而它的构成主要是用 Entry 来保存数据 ，而且还是继承的弱引用。在 Entry 内部使用 ThreadLocal 作为 key，使用我们设置的 value 作为 value。</p>
<h4 id="3-get-方法："><a href="#3-get-方法：" class="headerlink" title="3.get()方法："></a><strong>3.get () 方法：</strong></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//1、获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//2、获取当前线程的ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">//3、如果map数据不为空，</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">//3.1、获取threalLocalMap中存储的值</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) {</span><br><span class="line">                <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">   <span class="comment">//如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-remove-方法："><a href="#4-remove-方法：" class="headerlink" title="4.remove()方法："></a><strong>4.remove () 方法：</strong></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> {</span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">       <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">           m.remove(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>remove 方法，直接将 ThrealLocal 对应的值从当前线程 Thread 中的 ThreadLocalMap 中删除。</p>
<p><img data-src="/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3ThreadLocal/threadlocal1.png" alt="image-20231111205932328"></p>
<p>从图中我们可以当线程使用 threadlocal 时，是将 threadlocal 当做当前线程 thread 的属性 ThreadLocalMap 中的一个 Entry 的 key 值，实际上存放的变量是 Entry 的 value 值，我们实际要使用的值是 value 值。value 值为什么不存在并发问题呢，因为它只有一个线程能访问。threadlocal 我们可以当做一个索引看待，可以有多个 threadlocal 变量，不同的 threadlocal 对应于不同的 value 值，他们之间互不影响。ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</p>
<h4 id="5-内存泄漏原因"><a href="#5-内存泄漏原因" class="headerlink" title="5.内存泄漏原因"></a>5. 内存泄漏原因</h4><p>Entry 将 ThreadLocal 作为 Key，值作为 value 保存，它继承自 WeakReference，注意构造函数里的第一行代码 super (k)，这意味着 ThreadLocal 对象是一个「弱引用」。：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap 中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>
<p>主要两个原因<br>1 . 没有手动删除这个 Entry<br>2 . CurrentThread 当前线程依然运行</p>
<p> 第一点很好理解，只要在使用完下 ThreadLocal ，调用其 remove 方法删除对应的 Entry ，就能避免内存泄漏。<br> 第二点稍微复杂一点，由于 ThreadLocalMap 是 Thread 的一个属性，被当前线程所引用，所以 ThreadLocalMap 的生命周期跟 Thread 一样长。如果 threadlocal 变量被回收，那么当前线程的 threadlocal 变量副本指向的就是 key=null, 也即 entry (null,value), 那这个 entry 对应的 value 永远无法访问到。实际使用 ThreadLocal 场景都是采用线程池，而线程池中的线程都是复用的，这样就可能导致非常多的 entry (null,value) 出现，从而导致内存泄露。<br>综上， ThreadLocal 内存泄漏的根源是：<br>    <strong>由于 ThreadLocalMap 的生命周期跟 Thread 一样长，对于重复利用的线程来说，如果没有手动删除（remove () 方法）对应 key 就会导致 entry (null，value) 的对象越来越多，从而导致内存泄漏．</strong></p>
<p><strong>为什么不将 key 设置为强引用？</strong></p>
<p>如果 key 设计成强引用且没有手动 remove ()，那么 key 会和 value 一样伴随线程的整个生命周期。</p>
<p>   假设在业务代码中使用完 ThreadLocal, ThreadLocal ref 被回收了，但是因为 threadLocalMap 的 Entry 强引用了 threadLocal (key 就是 threadLocal), 造成 ThreadLocal 无法被回收。在没有手动删除 Entry 以及 CurrentThread (当前线程) 依然运行的前提下，始终有强引用链 CurrentThread Ref → CurrentThread →Map (ThreadLocalMap)-&gt; entry, Entry 就不会被回收 ( Entry 中包括了 ThreadLocal 实例和 value), 导致 Entry 内存泄漏也就是说: ThreadLocalMap 中的 key 使用了强引用，是无法完全避免内存泄漏的。</p>
<p><strong>为什么 key 要用弱引用</strong></p>
<p>事实上，在 ThreadLocalMap 中的 set/getEntry 方法中，会对 key 为 null（也即是 ThreadLocal 为 null ）进行判断，如果为 null 的话，那么会把 value 置为 null 的．<strong>这就意味着使用 threadLocal , CurrentThread 依然运行的前提下．就算忘记调用 remove 方法，弱引用比强引用可以多一层保障：弱引用的 ThreadLocal 会被回收．对应 value 在下一次 ThreadLocaI 调用 get ()/set ()/remove () 中的任一方法的时候会被清除，从而避免内存泄漏．</strong></p>
<h3 id="四、ThreadLocal与Thread，ThreadLocalMap之间的关系"><a href="#四、ThreadLocal与Thread，ThreadLocalMap之间的关系" class="headerlink" title="四、ThreadLocal与Thread，ThreadLocalMap之间的关系"></a>四、ThreadLocal 与 Thread，ThreadLocalMap 之间的关系</h3><p>ThreadLocalMap 其实是 Thread 线程的一个属性值，而 ThreadLocal 是维护 ThreadLocalMap 这个属性值的一个工具类。<em>Thread 线程可以拥有多个 ThreadLocal 维护的自己线程独享的共享变量</em>（这个共享变量只是针对自己线程里面共享）</p>
<h3 id="五、ThreadLocal与Synchronized区别"><a href="#五、ThreadLocal与Synchronized区别" class="headerlink" title="五、ThreadLocal与Synchronized区别"></a>五、ThreadLocal 与 Synchronized 区别</h3><p>ThreadLocal 和 Synchonized 都用于解决多线程并发访问同一个资源对象的时候，可能就会出现线程不安全的问题。</p>
<ul>
<li>ThreadLocal 是与一个线程绑定的本地变量，也就意味着这个变量是线程独有的，是不能与其他线程共享的。这样就可以避免资源竞争带来的多线程的问题。</li>
<li>加锁方式（synchronized、Lock) 用于在多个线程间通信时能够获得数据共享。</li>
</ul>
<p>但是，ThreadLocal 这种解决多线程安全问题的方式与加锁方式（synchronized、Lock) 是有本质的区别。</p>
<p><strong>两者区别如下：</strong></p>
<p>（1）资源管理方面</p>
<ul>
<li>Synchronized 通过加锁的方式，让多个线程之间逐一访问共享资源。</li>
<li>ThreadLocal 是每个线程都有一个资源副本，是不需要加锁的。</li>
</ul>
<p>（2）实现方式方面</p>
<ul>
<li>锁是通过时间换空间的做法。<br>Synchronized 是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。</li>
<li>ThreadLocal 是通过空间换时间的做法。<br>ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</li>
</ul>
<p>（3）使用场景方面</p>
<ul>
<li>多线程之间共享资源：使用加锁方式。</li>
<li>单线程内部独享：使用 ThreadLocal 变量。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="45bd089b1de20227a7d7b3d5ce9fe881a403e1aaa00d843f8e76a299673c8dbd">165d50f05814027fb7fe5e4ae8a088d86d0c1aba6d70b1044ca65dff1bf2218cbd3b930c090fc7b66d2adb6659e3ccf95194d3e32dc083e2525c89d0052fb19de71b1620ddb2e7b355e7ee5fd05404a69bda6c22a0217bd4d3d2594b3445ccdbdd7a6ee3d6676e7dd78202d7330cc589a3a37bb9a1c2ed57aa6a412412549c1174bc9e19ba7c2bde4b3a3741eefc5cc68e95b70c0a00ccc5a372d53193264017b841db02f3cb1075c920ab398c5211cb054c74f10325726f1c16e8fc83763e404b1b113d96993960687f92c8ac1d10f3fca18876cbc0fa7fb340506e08077070a07666c404b929089c6eea3c2be575036244cce40472eedda9d368ebf199068ed1801edf81f2ef3960be94fcaa3faefea541a6969a1dd75f0b309280079554b0500ceb8bddb9fe2e3702ef1887eef37b55501f49d8646c689f5191de7845e05f726a20f2bf742c0903616ba6512cb9a2dab598fa33f56efe0656a0ef415ab29d4fdce66f2b4b8b2d04fdd588f80ab2a6f1be05eebd022026147c53a13fe08dedf0e1ebf7a5a6d0fcb3be4fca14de3651dc4923cea3f4bbc6eb712f2033443f4236d2af85c634357e100c96baf4ec34cd276ffa6b4174d431d7e7eddc8a20ec0c7bc76eadf29a4e058c893d9a1bc1f7f106e7f4139bd4c648a411bad54f7ffa0692e3c34f0a23ed09ee9e4f8b1736c15ed54498192ef2b72112f78e9ec7d1f0eaaf4720f5b79c1c64eec1b712f2234725553d52a521c305d9483bc692f0d519b70fb11fbd82c7b36824e94d6a6912901ca5e3cac2bb883a7dcbd48781ac2b9812fdbe67557c43696708dd1fc07dcc13fa6e6754baed7845d3a09361c274a0f02e807ecc9587c11b39421a8e2fc3617f517afc211274a78191f29111729609fcfa78e0dbea7fa095f0a396d637c69c2d8fa1a8eb9fb9937869722a683d4e2e242fc8db1d33e8de90c3ad9aef4874d521231b68917439627c905cb9ec93b7069a45599317bc22580b418bfce93fd1e5e25702149dae50a437d058f7ee9e4fb7ff0b749da232430c1ea5eb47999f8e096f5f163ef19758805942efc792c029f76ba9a848836b98daf24cd3e4f1dca400cc8f712e9a9ac5130aa5e93af92eebdc9ea8f9444e72c3b0dd47d18525c926b99dd926abd8bd3ad36ff94c8c187ed723ea16261c42ee3c6805081158192b0c8eee32cd1dbaf5de40e8df8c14ad67b2237ca9382e305e54d461aefd4561d2a1f0cd1a0cccccf958d5cbefc3cc4f7d3a0acef63ea5c11ec7ef39387eec051a3c9fbff1c9405fa7c986a2f92276f42b72e27e5fc28350d161277acf2109938e258cf84592d6ef00c20651f504ff3fa633e824039e965a02e8396ca09b27f350de2d9fe84783760a1b47fea3bf73861162cacf532fd54f6e9c468e37750cc52c8003d6262875cc6624fcbd4946ddb8364cf7852b00f99ea448a7487b296fc5cc8c5c4c09e44f831219e30a2c34b420eaa28619bcea2f4daa9c0e0526b849400ccbe9bbf8b63191e13c1422edb1807ff8afa709f9c442f03d0f79d1eccb74086e1aae39212c9bdb1d49672f2df7540c57526fabe8b665a471e2f7e22ba1de4e0c9dbdb5e1806c2b2cf3b283c76db39f913dd25d702eef9dbe7720b0b035efe03aa4113ef69e219c4d0e80e4820b7ba41c56848f1eb994dbbb9ad77e015938afbac6d8a1ce73499ed5ba775d5b90354dddf5f21656f7929d3fc857820ebe22c47050b0939b4c6b736248ca65b853aad35bf864d0bd9f10f646fd45f34fbf0ced190feb2a6dab59a85217bc9ab43ed267c193acb4bf61787eccbda2cb2887f3cb4f2a8e37584367c23fc4a51ebec9fb2c991d68f2a731f788adb814519dca8275da89f484f9245f086e9992abcb6c999103538a9d324c5021d5c2728889654973d57164fa98beae7f46497e902a885e68548168f13af078bb35f959121f14ae14c1a1c56f752a8e58aed0cfea43e3e2dbc35ad8dfbbb562e65fdf7526774dbaf22f29f51acf6d821dea60abee4c6566c79612686fd6b4d6a8f0b4616503f17ffa226a0b4aaeff75eb93aeef889fd8ec341152bff787cabf58766ca9c35ef12b28b8b7bf1298a9c8b98acaf3d12f8e22cdc8e8bde3428759c283e093c330cbde6bf827a66c2929e04d32109fc914d3d87fe6603161888997a64492ffd95c6c19719326f29a36504302198153a527ee05e7fbb9acf8b79e5b392a530fc2b2f04f54a8bd2fbe235cd5e0594a8eaf86f7da345f4a9408d0d91abcf05ddfdccd26d745282d94359d09d6a4ab8888659e73c15aaa33d2dce980f9e69daffd9b54b8a71c52c956d0560820a3874733b054bca88c5a2014a990df2099265815ff08c13d0397a99f4c882b6c73427b9225839ca9a3230a355b2f8d02a620eb905ad9e7445cc96046a6a470e6ed4a8456ae29d6f04f8bcb346f1acb8346c9db128c9d34f152df424df8d2a37ebb4ab311481aed5de8a745e3ec63d672b6df27bc82897d152f94d2b7a87ce708620fe872cbd416ef2d09d8c38013776f6b6f08f6e5de6622cc78336a7f03e80d7c7f916c636556b8cf571766b93f1b68c20be6ef11e43da0a96fd56057fdf872b507c1a8c7a847adb9e5cd28ec6ceaedf19c7eb9318414c9c98ef4bbb796a4bea780a8aabcb268018d0fb8f3d7e1effe2371a13ef42b0c762468ff6784983d3d5b5557151d274d1e31b10abbf49846d2e55212ad210fb8d5454c2487f7da077a8ab67f88578517483a40ee407b9de0b61e3993cc41764d364b06c4047538a7df5a85630d52f02d6a88c65e36830607af4c5c2b25060689346528f70ff750c5bb38be1e921a579702a2f9fcb29bf32702e352e3a67369ebc0ccf577282d4a39539094a2991a9869f1102de2b38617401e2374cab1fb363004d383b1a29c7473b0f248d2def0bb302e3ba3c75f108fb973bb495647be7cdd46d2332e4e929d80ec7c4c396df0cf1a3a8146c9255181b65ed8b95c10cdbe7de6b3821ce33e99284d9aa136b7ce0a96c3aaa4fc8bdac1c7df134f3cfb6e65b88a13024b0064af805239eec4a105468be08336cfb3ce53db217d2cf14d6d039c5508bb0527323596f22e393bfea20ede34032cb56645720b7fc3ff3df8685fae750118b1cede1bfc424d1e5dab9e16e500afa381e2d85bc938b444f1d656b9b32e2605d880b82da236025a7f1029da2386138f5cf39903bd95dfb99efaa0d215575e71d464d772a5d7bfebcc598761344eff5b95ce0bb5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
</search>
